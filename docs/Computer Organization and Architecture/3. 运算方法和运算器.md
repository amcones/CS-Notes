## 定点数运算方法

均可以从竖式运算中得到灵感。

### 移位

原则上，移位运算的作用是乘除 2 的次幂，因此需要尽量保持运算的正确性，包括溢出、精度和符号。

1. 逻辑移位（无符号数）：直接移位
2. 算术移位（有符号数）：符号位保持不变，仅对数值移位。由于负数的原码、反码、补码各不相同，为了保持移位后各自保持的新的真值保持一致，添补规则不同。原码空位填 0，反码相反填 1，补码低位填 0，高位填 1。有 **另一种方法**，**符号位也参与移位**。左移符号变化发生溢出，右移添补符号。（可判定溢出且方便 ALU 处理）C 语言左移是逻辑左移，右移无符号逻辑右移，有符号算术右移。
3. 循环移位（无符号数）：移出的位出现在另一段。根据是否带 CF 进位标志位区分为小循环和大循环。相比小循环，大循环的循环中多了一个 CF 标志位中的初始值。主要运用在加密、哈希、优化算法。（增强混淆性）C 语言中没有提供。

### 加减法

由于采用补码，加减运算被极大简化。$[A+B]_补=[A]_补+[B]_补$，$[A-B]_补=[A]_补+[-B]_补$。

#### 溢出检测

两个操作数同号时才可能溢出。有三种方法：

1. 操作数符号位与运算结果符号位是否相同
2. 最高数值位 **进位** 与符号位 **进位** 是否一致
3. 变形补码，双符号位

双符号位检测简单且可判定正负溢出，但硬件成本高，适合手工运算。原理上与第二种类似。

#### 全加器

输入：操作数 $x_i$，操作数 $y_i$，进位 $c_i$。

输出：本位和 $s_i = x_i \oplus y_i \oplus c_i$，进位 $c_{i+1} = x_i \cdot y_i + (x_i \oplus y_i) \cdot c_i$。

应用：

1. 串行进位加法器：**进位串联**，进位信号依次传递，位数多时运算速度慢。器件少，成本低。
2. \*并行进位加法器：令 $G_i=x_iy_i$，$P_i=x_i \oplus y_i$，$C_{i+1}=G_i+P_iC_i$，$C_i$ 可以继续代换直到 $C_0$，不再依赖 $C_{i-1}$。$G_i$ 称为进位生成函数，$P_i$ 称为进位传递函数。位数越多，与门越多，成本越高，一般 4 个一组。内部只经过两个门。

### 乘法

循环进行加法，移位。

#### 软件实现

适用于没有乘法指令情况下实现乘法。需要反复执行多条指令，每条指令都需要经过“取指、译码、取数、执行、保存结果”，执行时间较长。

1. 无符号数乘法：$X$ 存被乘数，$ACC$ 存积的高位，$MQ$ 存被乘数/积的低位，$C_{out}$ 触发器存进位。控制逻辑、$C_n$ 计数器存加法、移位操作次数，由时钟信号驱动。每一轮进行两种操作：
   1. 若 $MQ_0 \neq 1$，($X$) + ($ACC$) -> ($ACC$)
   2. ($C_{out}$),($ACC$),($MQ$) >> 1，随后 $C_n$ 减 1。
2. 原码乘法：比无符号数多一个符号位处理，符号位异或一下即可。
3. 补码乘法：与前面形式类似，不同在于每一步部分积加法中，都加上 $(y_{i+1}-y_i)[x]_补$，即 $y$ 的高一位与低一位的差（-1，0，1）。在乘数 $y$ 的最后添加一位辅助位 $y_{n+1} = 0$（以保持形式一致）。考虑到运算中可能出现绝对值大于 1 的情况，$ACC$ 和 $X$ 取 **双符号位**。

#### 硬件实现

分为使用 ALU 和位移器实现的乘法指令（通用硬件实现，一条指令多个周期）和阵列乘法器实现的乘法指令（专用硬件实现，一条指令一个周期）。

1. 无符号阵列乘法器：与门与全加器模拟竖式计算。进位输入为 0 的全加器可改为半加器以减少逻辑门数量，最后一行全加器可改为先行进位电路以优化效率，适合超大规模集成电路实现。
2. 补码阵列乘法器：单独处理符号位，数值位转为原码，按无符号处理，再转回补码。转换过程使用求补电路。

### 除法

二进制除法就是不断重复除数减法和左移，其中减法可用补码加法替代。

1. 原码除法运算（恢复余数法）

   符号位与数值分开处理。由于计算机无法判断大小，只能默认“够减”，如果不够再加回去，这个过程叫“恢复余数”。最大缺点是运行时间不确定（每步运算是否恢复余数），控制电路也比较复杂。为防止溢出，要求小数 $|被除数|\lt |除数|$，整数 $|被除数| \geq |除数|$。
2. 原码除法运算（不恢复余数法，又称加减交替法）

   $$
   \begin{cases}
      R_{i+1}=2R_i-y,Q_i=1 &R_i\geq 0\\
      R_{i+1}=2R_i+y,Q_i=0 &R_i\lt 0\\
   \end{cases}
   $$

   先左移，然后加减除数。注意：

   1. 最后一次运算上商时，如果余数小于 0，此时虽然已经得到所有上商位，但余数还要加上除数恢复成正数
   2. 进位与上商位一致，所以可以用加法器的进位输出作为上商的控制信号以及可控加减法电路的控制信号
3. \*补码除法运算（不恢复余数法）

   符号位和数值位一起参与运算。

   1. 商值：被除数与除数异号，不“够减”，做加法。
   2. 商符：求商过程自然形成
   3. 新余数：与加减交替法类似。对商的精度没有特殊要求末位可恒置 1。

   简单来说，除法都是每次重复加法，上商，左移。每次加法看余数符号，加上符号相反的除数（$[y]_补$ 或 $[-y]_补$）。上商看新余数的符号，与 $[y]_补$ 同号上商 1，否则 0。理解起来很困难，但是运算规则很简单。

## 浮点数运算方法

### 加减法

（变形）补码表示：

1. 对阶：小阶向大阶看齐，尾数右移相应位数。
2. 尾数运算：相加
3. 结果规格化：考虑溢出
4. 舍入：截断，置 1，0 舍 1 入。

IEEE754 标准：

1. 对阶和规格化中，阶码加减采用 **移码** 加减。
2. 尾数采用原码运算，且隐藏位要参与。
3. 规格化：

   1. 尾数形式为 1.，已规格化
   2. 尾数形式为 0.，左规
   3. 尾数形式为 1b.，右规 1 次
4. 舍入：
   1. 就近舍入，舍入到最近可表示数，若在两数中间则向偶数舍入
   2. 朝正无穷方向舍入，总是取最右侧可表示的最近的数
   3. 朝负无穷方向舍入，相反
   4. 截断，朝 0 方向舍入
5. 溢出判断：判断阶码溢出。右规使阶码为全 1 时规格化上溢，左规使阶码为全 0 时规格化下溢。

### \*乘法

1. 阶码相加：定点整数相加，可能溢出
2. 尾数相乘：定点小数乘法，可能需要规格化和舍入
3. 规格化和舍入：与浮点加减法相同

对于 IEEE754：

- 阶码采用移码运算
- 尾数相乘时隐藏位也要参与
- IEEE 754的规格化和溢出检测
- 不存在向左规格化

### \*除法

与乘法思想类似。

## 运算器

分为定点运算器，以 ALU 为核心，和浮点运算器，以 FPU 为核心。

ALU 可封装为有 $A$，$B$ 操作数，$ALU_{op}$ 操作指令，$C_{in}$ 进位等输入，$F$，$C_{out}$ 等输出的结构。可以通过串联构成 $n$ 位 ALU。除了运算结果外，还包含若干状态标志位：

- ZF(Zero Flag)：结果为 0
- OF(Overflow Flag)：有符号运算溢出
- SF(Sign Flag)：负数
- CF(Carry out Flag)：加法进位输出、减法借位输出、逻辑左移的溢出位

有些计算机将标志位暂存在一个状态寄存器中，有些没有。

定点运算器除了 ALU 外，还包括通用寄存器组，缓冲寄存器等，用内部总线连接。
