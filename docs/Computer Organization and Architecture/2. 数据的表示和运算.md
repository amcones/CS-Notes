## 数制与编码

- 无符号数
- 有符号数
  - 定点数
    - 整数
    - 小数
  - 浮点数
    - 单精度
    - 双精度

### 定点数编码

通常将在计算机内部编码表示后的数称为机器数，而机器数真正的值(即现实世界中带正负号的值）称为真值。机器码中，整数将符号位与数值位用逗号隔开，小数用小数点。

> 显然，机器码与现实世界中数的二进制表示是不同的，只有原码最接近。

机器码主要要解决的问题就是负数的表示，毕竟机器没有负号。四种编码都各自需要解决整个数轴的映射问题。

- 原码：拿最高位做符号位
- 补码：原码在模意义下的加法逆元
- 反码：原码除符号位按位取反
- 移码：真值加一个常数 $2^n$，把负数全部提到前面一半

最有用的是补码，因为符号位可以直接参与运算且消除了减法。对计算补码有三种方法：

1. 定义法：$2^n - x$。（已知十进制）
2. 反码法：逐位取反加 1。（已知二进制）
3. 扫描法：从低到高找到第一个 1，比 1 高的位按位取反。

### 浮点数表示

1. 基数（隐含 2）、阶码（定点整数）、尾数（定点小数）

    对于定点小数，假设有 n+1 位，第一位符号位，则能表示的最大数字是 $\sum\limits_{i=1}^n 2^{-n}=\frac{\frac{1}{2}(1-2^{-n})}{1-\frac{1}{2}}=1-2^{-n}$。也可以与整数当中最大值是 $2^n-1$ ，与进位差一个最高位结合理解，小数与 1 之间差一个最高位。

    注意，阶码表示右移位数的次幂，比如阶码为 3 时表示右移 $2^3=8$ 位。

2. 浮点数的规格化：通过左移/右移使得尾数的最高位必须是一个有效值，使浮点数表示形式唯一且 **精度最高**。有效最高位的位数与基数 $r$ 有关，具体来说是 $\log_2 r$ 位。分为左规和右规：左规表示尾数小了，扩大；右规是尾数溢出了，缩小。
3. **IEEE 754**：规定阶码、尾码长度和采用何种编码。阶码用移码，尾码用原码。由于移码不考虑符号位，看成无符号整数。但 IEEE 754 使用的偏移常数是 $2^r-1$ 而不是 $2^r$。这样做的原因是把阶码全 1 或全 0 的数作为特殊用途，且避免倒数溢出。由于全 1 和全 0 都留出来了，所以阶码最小值能取到 $2^r-2$。尾数也略有不同，在尾数前隐含一个 1，格式为 1.M，实际尾数 24 位，符号位移到最前面。
   1. 单精度浮点数：从高到底，最高符号位，8 位阶码，23 位尾数。
   2. 双精度浮点数：从高到底，最高符号位，11 位阶码，52 位尾数。
   3. 阶码全 1，尾数为 0 表示正负无穷，尾数不为 0 表示 NaN。
   4. 阶码全 0，尾数为 0 表示正负 0，尾数不为 0 表示非规格正数（处理阶码下溢）。
    ![IEEE 754](https://ulipic-1258663779.cos.ap-shanghai.myqcloud.com/ulog/%E6%88%AA%E5%B1%8F2025-06-16%2000.30.20.png)

???+ warning "注意"
    注意，IEEE 标准下，由于隐藏了一位 1，导致尾码的等比数列计算多了一项！即 $\sum\limits_{i=0}^n 2^{-n}=\frac{1(1-2^{-n})}{1-\frac{1}{2}}=2-2^{-n+1}$。在 float 中就是 $2-2^{-23}$。

### C 语言数据类型转换

注意，整数以补码存储。

- 整数：从数值上来说，正数只要存得下就保持不变；负数在有符号类型存得下也保持不变，到无符号类型变为补数。两者存不下都直接截断，然后考虑符号位，数值位。
- 浮点数：float->double 保持不变，double->float 大数溢出，高精度舍入，float/double->int 小数部分向 0 截断，大数溢出，int->float float 尾数只有 24 位，int 的高 8 位无法表示，发生精度溢出，int->double 保持不变。
