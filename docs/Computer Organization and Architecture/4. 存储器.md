## 概述

### 存储器性能指标

1. 存取速度

    1. 存取时间：读/写操作的时间。读的时间和写的时间可能不同。
    2. 存取周期：连续两次操作之间的时间间隔
    3. 存储器带宽：单位时间内传输信息量

2. 存储容量：存储字长*存储单元数量。主存（内存）的容量=$2^\textit{MAR}\times \textit{MDR}$。

### 主存的基本结构

$\textit{MAR}$ 的值经过地址译码器（如 3-8 译码器）映射成二进制位，对应每个存储单元的地址。CPU 通过地址总线写入 $\textit{MAR}$，再通过控制总线写到 $\textit{MDR}$，再从数据总线将 $\textit{MDR}$ 数据读到 CPU。写过程相反。

### 译码结构

单译码和双译码（行列）。输入地址线相同，输出地址线双译码比单译码少 $2^{n-1}$条。

### 数据存放

1. 机器字长与存储字长：前者是 CPU 一次能够处理的二进制数据位数，后者是一个存储单元存储的二进制位长度。
2. 地址访问模式：地址按字节编址，存储字长是字节的 2 的整数次幂（1B，2B，4B 等）。可以按字节访问，也可以按半字、字地址访问，可以进行逻辑右移得到地址。
3. **大端、小端储存方式**：

   1. 小端：数据的低字节保存在主存的低地址中，高字节保存在高地址中。高地址储存的数据权值高，符合逻辑。
   2. 大端：相反。数字从左到右对应存储地址增长方向，符合人类习惯。
4. **边界对齐**：在一次存储周期内读取一个数据，提高访问性能。简单来说就是确保起始字节地址是数据长度的整数倍，对应二进制就是末 $n$ 位为 0（快速找到下一个地址的技巧）。

???+ warning "注意"
    注意，大端、小端存储方式只是对存储单元的地址而言，每个存储单元内部的数据顺序并没有调整！

## SRAM

静态（无需刷新）随机存取存储器，一般用 （6 个）MOS 管构成。使用晶体管数量多，需要通过负载管不断为工作管提供电流以保存信息，功耗大，成本高，但由于不用刷新速度快，常用于 cache。

- 存储元扩展：行选通线并联，位线并联，一列的位线上共享两个 MOS 管，并联两条位线送到 I/O 电路。同一时刻只能有一条行选通线和列选通线输出有效信号，就是只有一个存储元被选中。构成 **存储阵列**。

    ![存储元扩展](https://ulipic-1258663779.cos.ap-shanghai.myqcloud.com/ulog/%E6%88%AA%E5%B1%8F2025-06-22%2018.47.10.png)

- 存储阵列扩展：并联行选通线和列选通线，同时选中多个存储阵列中同一位置的存储元，构成 **存储体**。

### 芯片实例

除了内部结构，还需要在外部加上驱动器以增加译码器负载能力，以及控制电路，包含 **写使能信号** $\overline{WE}$ 和 **片选信号** $\overline{CS}$ 用于连接多块 SRAM 芯片时选择某一片进行工作。输出到 I/O 电路经过差分放大器送到数据总线。

引脚包含 $\overline{WE}$，$\overline{CS}$，行地址，列地址和数据引脚（不包括电源 $V_{\textit{cc}}$ 和接地 $\textit{GND}$）。

## DRAM

动态随机存取存储器。用一个 MOS 管和一个电容构成，写入时给电容充电，读出时电容会放电（破坏原数据），且会通过 MOS 管漏电，因此要不断刷新。

行信号选通时，同一行上的存储元都会向列线漏电/充电，列线上的电压就会增加或减少，存储数据被破坏，灵敏读出/恢复放大器根据这个来读数据。同时由于灵敏读出/恢复放大器含有锁存器，重新恢复刚读出的数据。

### 动态刷新

- 刷新周期：从存入开始到数据丢失之前为止的时间称为最大刷新周期。
- 刷新存储元的数量：与读出一样，按行进行刷新。为了缩短刷新周期，可减少行数增加列数。
- 刷新与读操作区别：刷新不用给出列地址。

刷新时不能响应 CPU。有三种刷新方式：

1. 集中刷新：集中刷新时间 CPU 长时间无法访问 DRAM
2. 分散刷新：刷新过于频繁
3. 异步刷新：结合前两种，把刷新周期分成行数块，每块最后刷新。

### 存储器实例

采用分时地址复用技术，公用行地址线和列地址线，从而减少一半的地址线。

含有列选通 $\overline{CAS}$、行选通 $\overline{RAS}$、读写控制 $\overline{WE}$，数据引脚，以及地址引脚（不包括电源 $V_{\textit{cc}}$ 和接地 $\textit{GND}$）。

## ROM

现在主流 EEROM 和 闪存 Flash，都允许多次写入。EEPROM 支持字节级擦写，闪存以块为单位擦写，更适合存大块数据。写前要先擦后写，因此读快写慢。EEROM 一般用于网卡、BIOS，Flash 一般用于 SD 卡、U 盘、SSD、BIOS。

## 主存的扩展及其与 CPU 的连接

### 位扩展

**扩展数据宽度。** 利用多出的数据总线。存储芯片的数据总线位宽小于 CPU 的数据总线位宽，用多块存储芯片扩展，每块给出一部分位数。具体来说，地址总线与每块芯片并联，同时选中每块芯片的同一个地址，然后每块芯片从各自相连的数据总线传输数据。又称数据总线扩展、字长扩展。

### 字扩展

**扩展存储容量。** 利用多出的地址总线。用多出来的地址总线连到译码器，再从译码器连到每片存储芯片的片选信号，从而选中某片芯片。又称容量扩展或地址总线扩展。

容易想到字位可以同时扩展。先扩展位，看作是芯片组，再对芯片组扩展字。

### CPU 连接

CPU 包含地址总线引脚、数据总线引脚、存储器请求控制引脚 $\overline{MREQ}$ 和读写控制引脚 $R/W\#$。

主存一般包含 RAM 和 ROM，它们统一编址。考虑地址线数量时，先考虑给芯片内部每个存储单元编号所需要的地址线，再考虑区分每个芯片需要的地址线。

## 主存系统的优化

- 双端口存储器：两个 CPU 并行读写存储器，发生冲突时（死锁）采用信号量的方式，用 $\overline{\textit{BUSY}}_1$ 和 $\overline{\textit{BUSY}}_2$ 两个端口控制其中一个延迟访问。由于冲突是不可避免的，所以速度不会提高一倍。
- 单体多字存储器：与位扩展方式完全相同，扩展多个内存条。
- 多体交叉存储器：分为高位多体交叉和低位多体交叉，其中高位与字扩展完全相同，也称为顺序编址模式（扩展容量），程序基本分布在一个模块里，导致一个繁忙其它空闲。低位（也称为交叉编址模式）将模块地址放在低位，程序存在不同模块中，能够并行。按流水线方式轮流存取。

## 高速缓冲存储器 cache

实现 cache 的关键技术：

- 数据查找（与地址映射相关）
- 地址映射
- 替换策略
- 写入策略

### 性能评价

- 程序局部性：

  1. 时间局部性：某一时刻访问的位置未来很可能被多次访问
  2. 空间局部性：访问的某一位置附近也可能被访问

CPU 不再直接访问主存，而是先在 cache 中访问。在 cache 中找到称为命中，没找到则需要从主存调入。

- 缺失补偿 = cache 内查找时间 + 主存访问时间（长） + cache 访问时间
- 为方便查找，主存和 cache 都划分为若干个固定大小的数据块，加载时按照块加载，利用程序的空间局部性。分块过小无法利用空间局部性，分块过大替换算法无法利用时间局部性。数据块的地址由块地址和块内偏移地址（Offset）构成。
- 性能评价：某程序运行期间命中次数记为 $n_c$，从主存中访问信息次数记为 $n_m$，命中率记为 $h$：
    $$
    h = \frac{n_c}{n_c+n_m}
    $$
    $1-h$ 称为 **缺失率**。命中情况下访问时间记为 $t_c$，缺失情况下访问时间记为 $t_m$，系统 **平均访问时间** 记为 $t_a$：
    $$
    t_a= h\cdot t_c+(1-h)t_m
    $$
    **访问效率** 记为 $e=\frac{t_c}{t_a}=\frac{t_c}{h\cdot t_c+(1-h)t_m}=\frac{1}{h+(1-h)\frac{t_m}{t_c}}=\frac{1}{h+(1-h)r}$。$r$ 值反映了主存访问时间和 cache 访问时间的差距，不能太大，一般为 5 到 10。

### 读写操作

- 写策略：

  1. 命中
     1. 写回：写入 cache 就返回，会产生不一致性（脏数据），快
     2. 写穿：写入 cache 后再写入主存，慢
  2. 缺失
     1. 非写分配策略：只写到主存
     2. 写分配：先载入，为缺失数据分配 cache 数据块，可能要进行数据块替换，再按照写命中操作

写回策略在 cache 写满时，需要将脏数据写到主存，然后从主存载入新数据块到 cache 后才能向 cache 写数据，比没有采用 cache 的主存还要慢。

### 地址映射

重点是主存地址构成和 cache 行地址构成。

- 直接映射：
  - cache 行：有效位，主存分区号，数据块副本
  - 主存地址：主存分区号，cache 行索引（区内块号），块内偏移
- 全相联映射（没有分区概念）：
  - cache 行：有效位，主存数据块地址，数据块副本
  - 主存地址：数据块地址，块内偏移
- 组相联映射：
  - cache 行：有效位，区内块号，数据块副本
  - 主存地址：主存分区号，cache 行索引（区内块号），块内偏移

注意写策略对 cache 地址构成的影响，可能有 1 位脏位（修改位）。

组相联映射相当于全相联映射从数据块地址拿一部分位数出来，用来表示分区。

### 替换算法

- FIFO：最后加载的最后淘汰
- LFU：访问最多的最后淘汰
- LRU：最近访问的最后淘汰
- 随机

淘汰计数器的位数是组数的对数。

### 写入策略

- 写命中
  - 写回方式
  - 写穿方式
- 写未命中
  - 写分配法：将写入的数据块放入 cache
    - 写回方式
    - 写穿方式
  - 非写分配法：只写主存，不写 cache

写回就是数据最终写到 cache 上，只有替换时才写到主存；写穿就是 cache 和主存都写。

## （页式）虚拟存储器

把主存和辅存一起看成可供 CPU 直接访问的超大容量主存，即将主存作为辅存的缓存。需要软件（OS）和硬件（MMU）协作。

### 地址映射

由于页缺失的代价很大，所以采用全相联映射与写回策略，且页设置比较大。主存中常驻一个页表，用于存储虚拟页号与物理页号的映射，而页内偏移虚拟和物理一致，所以根据虚拟页内偏移地址与物理页号拼接构造出物理地址。

### 快表 TLB

由于虚拟存储器系统会减慢存储系统速度，加上 TLB 作为专门存储页表的 cache，TLB 内的页表叫做快表，主存内的叫慢表。TLB 一般采用全相联或组相联映射，随机替换算法。

### 访问流程

OS 引导完成前 CPU 使用物理地址，称为实模式，引导完成后使用虚拟地址，称为虚模式。

CPU 给 MMU 虚拟地址，MMU 先到 TLB 中找，缺失再到 cache 找（可选），还缺失再到主存找，还缺失触发操作系统缺页异常，从外存调入页到主存，更新 TLB，重新启动发生缺页的指令。当中任何一步命中，就根据页表找数据，如果 cache 当中有就读 cache 数据，没有就到主存找数据。找到页，就更新 TLB。

结论：TLB 命中，则页一定命中（直接得到物理页号）；页缺失则 cache 不可能命中（页缺失意味着页面不在主存里，cache 不可能缓存主存没有的数据）
